<html>
  <head>
    <!-- Load the latest version of TensorFlow.js -->
    <!--script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.6.0/dist/tf.min.js"></script>-->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
  </head>
  <body>
    <div id="console"></div>
    <!-- Add an image that we will use to test -->
    <!-- Load index.js after the content of the page -->
    <!-- script src="tiny-yolov2.min.js"></script> -->
    <script src="tiny-yolov2.js"></script>
    <script src="FileSaver.js"></script>
    <script src="createLossReporter.js"></script>
    <!--script src="TinyYolov2Trainable.js"></script>-->
    
    <script>
        
        function shuffleArray(a) {
            var array = a.slice();
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var x = array[i];
                array[i] = array[j];
                array[j] = x;
            }
            return array;
        }

        async function app(){
            const config = {
              // use separable convolutions over regular convolutions
              "withSeparableConvs": true,
              // iou threshold for nonMaxSuppression
              "iouThreshold": 0.4,
              // instructions for how to determine anchors is given below
              "anchors": [
                { "x": 1.08, "y": 1.19 },
                { "x": 3.42, "y": 4.41 },
                { "x": 6.63, "y": 11.38 },
                { "x": 9.42, "y": 5.11 },
                { "x": 16.62, "y": 10.52 }
              ],
              // whatever kind of objects you are training your object detector on
              "classes": ["duck"],
              // optionally you can compute the mean RGB value for your dataset and
              // pass it in the config for performing mean value subtraction on your
              // input images
              "meanRgb": [100,100,100],
              // scale factors for each loss term (only required for training),
              // explained below
              "objectScale": 5,
              "noObjectScale": 1,
              "coordScale": 1,
              "classScale": 1
            }

            // simply use any of the optimizer provided by tfjs (I usually use adam)
            const learningRate = 0.001
            const optimizer = yolo.tf.train.adam(learningRate, 0.9, 0.999, 1e-8)
            
            // initialize a trainable TinyYolov2
            const net = new yolo.TinyYolov2Trainable(config, optimizer)
            
            // load initial weights or the weights of any checkpoint
            const checkpointUri = 'http://127.0.0.1:3000/initial_glorot_1_classes.weights'
            const weights = new Float32Array(await (await fetch(checkpointUri)).arrayBuffer())
            await net.load(weights)


            
            
            //const boxJsonUris = (await fetch('http://127.0.0.1:3000/BoxJsonUris')).json()
            const boxJsonUris = ['http://127.0.0.1:3000/duck1.json','http://127.0.0.1:3000/duck2.json']
            console.log(JSON.stringify(boxJsonUris))
            
            const trainingSizes = [160, 224, 320, 416]
            const lossReporter = createLossReporter(trainingSizes)
            const startEpoch = 0
            const maxEpoch = 50
            var saveEveryNthSample = 500
            
            
            function saveWeights(net, filename = 'train_tmp') {
              saveAs(new Blob([net.serializeParams()]), filename)
            }
            function onBackwardComplete(epoch, dataIdx, inputSize) {
              const idx = dataIdx + 1

              if (inputSize === trainingSizes[trainingSizes.length - 1] && (idx % saveEveryNthSample) === 0) {
                saveWeights(net, `voc_e${epoch}_${idx}.weights`)
                saveAs(new Blob([JSON.stringify(lossReporter.summary())]), `voc_e${epoch}_${idx}.json`)
              }
            }
            for (let epoch = startEpoch; epoch < maxEpoch; epoch++) {
              console.log('epoch : ', epoch)
              // always shuffle your inputs for each epoch
              const shuffledInputs = shuffleArray(boxJsonUris)

              //if (epoch !== startEpoch) {
              //  saveWeights(net, `custom_epoch${epoch - 1}.weights`)
              //  saveAs(new Blob([JSON.stringify(lossReporter.summary())]), `custom_losses_epoch${epoch - 1}.json`)
              //}

              lossReporter.resetLosses()

              // loop through shuffled inputs
              for (let dataIdx = 0; dataIdx < shuffledInputs.length; dataIdx++) {

                // fetch image and corresponding ground truth bounding boxes
                const boxJsonUri = shuffledInputs[dataIdx]
                //console.log('Debug5 : ',boxJsonUri)
                const imgUri = boxJsonUri.replace('.json', '.jpg')
                //console.log('Debug6 : ',imgUri)
                const groundTruth = await (await fetch(boxJsonUri)).json()
                //console.log('Debug7 : ',groundTruth)
                const img = await yolo.bufferToImage(await (await fetch(imgUri)).blob())
                //console.log('Debug8 : ',img)
                // rescale and backward pass input image for each input size
                for (let sizeIdx = 0; sizeIdx < trainingSizes.length; sizeIdx++) {

                  const inputSize = trainingSizes[sizeIdx]
                  //console.log("debug10 : ", inputSize, "    ", sizeIdx)

                  const backwardOptions = {
                    // filter boxes with width < 32 or height < 32
                    minBoxSize: 32,
                    // log computed losses
                    reportLosses: function({ losses, numBoxes, inputSize }) {
                      console.log(`ground truth boxes: ${numBoxes} (${inputSize})`)
                      console.log(`noObjectLoss[${dataIdx}]: ${yolo.round(losses.noObjectLoss, 4)}`)
                      console.log(`objectLoss[${dataIdx}]: ${yolo.round(losses.objectLoss, 4)}`)
                      console.log(`coordLoss[${dataIdx}]: ${yolo.round(losses.coordLoss, 4)}`)
                      console.log(`classLoss[${dataIdx}]: ${yolo.round(losses.classLoss, 4)}`)
                      console.log(`totalLoss[${dataIdx}]: ${yolo.round(losses.totalLoss, 4)}`)
                      lossReporter.reportLosses({ losses, numBoxes, inputSize })
                    }
                  }
                  //console.log("debug11 : ", backwardOptions)

                  const loss = await net.backward(img, groundTruth, inputSize, backwardOptions)
                  
                  //onBackwardComplete(epoch, dataIdx, inputSize)
                  if (loss) {
                    // don't forget to free the loss tensor
                    loss.dispose()
                  } else {
                    console.log('no boxes remaining after filtering')
                  }

                }
              }
              if (epoch !== startEpoch && epoch %10 == 0) {
                saveWeights(net, `custom_epoch${epoch - 1}.weights`)
                saveAs(new Blob([JSON.stringify(lossReporter.summary())]), `custom_losses_epoch${epoch - 1}.json`)
              }
            }
            console.log("train Ended")
        }
    
        app();

        
        
    </script>
    
    
    
    
  </body>
</html>
